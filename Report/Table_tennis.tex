\documentclass[a4paper]{article}

%% Useful packages
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}	
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=black]{hyperref}
\usepackage[fontsize=11pt]{scrextend}
\usepackage{titlesec}
\usepackage[section]{placeins}
\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\setlength\parindent{0pt}
\setlength{\parskip}{1em}
\titleformat*{\section}{\Large\bfseries}
\titleformat*{\subsection}{\Large\bfseries}

\title{3D Trajectory in Sports - Table Tennis}

\begin{document}

\begin{titlepage}
\begin{figure}
\centering
\includegraphics[width=0.2\textwidth]{polimi.jpg}
\par
\LARGE Politecnico di Milano
\end{figure}


\maketitle
\textbf{Version 1.0}
\newline

\raggedright
Authors:
\begin{itemize}
	\item Matheus FIM (Mat. 876069)
    \item Reda AISSAOUI (Mat. xxxxxx)

\end{itemize}
\raggedleft
Prof. Vincenzo CAGLIOTI
\thispagestyle{empty}
\end{titlepage}


\tableofcontents
\newpage
 
\section{Problem Formulation}

Table tennis is a demanding sport where the referees have to pay attention at a complex set of rules at all moments. For this reason, much can be obtained from having in-place a system capable of reconstructing the 3D trajectory of the ball during the course of a point. For instance, eventually unclear plays can be decided correctly or even coaches can better analyse the players performance. However this is not a simple task. Many of the techniques applied to other sports cannot be used for this context, as the table tennis ball can be hard to detect due to its reduced dimension and also cannot be relied to follow a parabolic trajectory as its small mass causes it to be heavily affected by the air resistance.

The proposed system takes as input real matches video sequences and is able to overcome a wide variety of problems, such as high object motion, blurring, uneven lighting, background merging, object confusion and occlusion. Thus generating as output an estimation of the 3D trajectory of the ball. The algorithm relies on videos recorded by two non synchronized RGB  cameras and uses this information to detect the table, calibrate the cameras, track the ball in between frames, synchronize the cameras and finally combine the single trajectories for the production of the 3D trajectory.

The Experiments were conducted on 60fps and 120fps video samples recorded with GOPRO cameras in an indoor environment and produced satisfactory results. In all tests the trajectory was estimated with suitable accuracy, whereas the most satisfying results were experienced in the higher fps videos. Also, the adaptive "region of interest" allowed to reduce both the time of execution of the algorithm and the incidence of false positives. 
   
  
\section{State of the Art}

Wong et. al.\cite{Wong} described an algorithm capable of tracking table tennis balls in services and stated the accuracy was high enough for umpiring applications. Their work handled the following problems:

\begin{itemize}
\item \textbf{High object motion:} The high speed of the ball may cause it to be blurred, colour faded and distorted in shaped.
\item \textbf{Multiple moving objects:} Apart from the ball, the players, the rackets and background elements in the scene exhibit motion.  
\item \textbf{Uneven lighting:} Light sources on the ceiling tends to cause the ball to be brighter at the top than at the bottom.
\item \textbf{Occlusion:} The ball can be blocked by the player, by the rackets, or even disappear from the field of view in the upper part of the video.
\item \textbf{Merging:} Low contrast from the ball and the background may cause difficulties in distinguishing both.
\item \textbf{Object Confusion:} Objects in the background with similar color (e.g. human skin) and shapes (e.g. a bald person head) may be confused with the ball. 
\item \textbf{Small size:} Size of the ball is only a fraction of the frame, which randers histogram-based detection unsuitable.
\item \textbf{Time constraint:} latency from detecting to tracking the ball must be minimised.
\end{itemize}

In order to overcome these issues it is proposed a method that executes an object segmentation followed by a object evaluation algorithm. The object segmentation is composed by a two-pass thresholding (TPT) algorithm, capable of adapting the threshold according to context. The first pass highlights only elements of the frame with a highly similar color to the one of the ball, and the second thresholding relax the constraints in order to reconstruct the shape of the object. The output is a set of candidate balls to be further evaluated by the object evaluation algorithm. This second algorithm is also executed in two steps. In the first it is controlled if the individuated object displays an upper rounded contour, its location is consistent with the predicted location and if it exhibits motion both at its centre and in the predicted location. And in the second, from the set of objects that were able to pass the first step, one is chosen as the ball based on spatial geometric measurements (area, maximum width, maximum height, perimeter, roundness, and error on the rounded upper contour).

These elements are going to be further discussed in the document as they were applied in the project. 

\textbf{Tamaki and Saito(20..)} proposed a method of reconstructing 3D trajectories of table tennis balls. They consider both the problem reconstructing the trajectory from two rgb cameras and from one rgb-d camera (i.e. capable of providing depth information). One of the novel approaches is the method that approximates that a ball is travelling on tilted planes, and thus it is able to accurately identify which of the possible candidates is the ball. Also they leverage on the work produced by\textbf{ Zhang (CITE)} to compute the camera intrinsics ... (continue)


\section{Solution}

The proposed solution is divided in table tennis detection, camera calibration, ball tracking, 2D trajectory estimation, camera synchronization and 3D trajectory estimation. 

\subsection{Setup Phase}
	selection of the ball...

\subsection{Table detection}

In order to take detect the table, we have to take advantage of its features. The table edges are long straight lines. It is also blue and stands out from its environment. So our approach consists of finding the lines present in the input image and then filter them according to different criteria. After that, the lines are grouped depending on which side of the table they belong to. From this group of lines, the four sides of the table is calculated

\subsubsection{Lines detection}

Using Hough peaks and Hough lines, the algorithm start by detecting the lines that are present in the input image. We consider as a valid lines the ones that are on the edge of the table. The lines are therefore filtered on the following criteria:
\bigbreak
\textbf{Orientation}

Given the point of view of the camera, we don't expect to have an edge of the table showing vertically on the image. Hough lines algorithm uses a polar coordinates system, therefore we filter the lines directly from $\theta$ of the polar coordinates.
\bigbreak
\textbf{Color separation}

A valid line will have from one side the blue table color and then from the other side any other color (floor green, wall white...). To decide which lines are valid, two sample pixels are taken from each side of the line. The midpoint of the line along with the orthogonal line going through the midpoint are calculated. The sample pixels are equally distant points from the centroid on the orthogonal lines. The HSV values of these points are considered as it is a more robust way to deduce the color.

Given two points $p_{1} = (h_{1}, s_{1}, v_{1})$ and $p_{2} = (h_{2}, s_{2}, v_{2})$, a color is considered blue if

$blue_{1} = (h_{1} > BLUEMIN) \wedge (h_{1} < BLUEMAX) \wedge (h_{1} > VLIGHTMIN)$

where the thresholds (BLUEMIN, BLUEMAX and VLIGHTMIN) are defined from the hue values of the blue color. A minimum value of brightness is also imposed as blacks may be considered as blue.

A line is considered valid if

$line = blue_{1} \veebar blue_{2}$  

\subsubsection{Lines grouping}

Still needs to be developed 

After detecting the lines on the edge of the table we need to cluster them using kmeans ....

Because of the distortion caused by the wide angle lens, the lines detection algorithm sometimes return many lines for one table edge.

we have multiple lines per edge =>  weighted average grouping

then grouping => calculate intersects and then finished

\subsection{Camera Calibration}
\subsection{Ball Tracking}

The ball tracking is done using Wong et. al.\cite{Wong} algorithm. The candidate objects are individuated in an object segmentation phase (two-pass-thresholding algorithm) and then selected based on an object evaluation step (ball selection algorithm). 

\subsubsection{Object Segmentation}

The objective is to segment candidate balls from the other elements in the frame. Candidate balls are objects that exhibit similar properties to the object of interest (OOI). To perform this segmentation it is implemented a color thresholding algorithm. The basic idea is to create a binary differential image where pixels with a color similar to the one of the ball are turned white while other are turned black, the neighbouring white pixels are then merge together to form an object. However, to increase precision this is divided in two passes. In the first, a coarse threshold is applied so only pixels with a sufficiently similar color to the ball are filtered, the pixels are then grouped as described above. This first thresholding operation is expected to produce a distorted object, since the coarse threshold may cause small color variations due to lighting or movement to be ignored. In this matter, the second pass is applied only on the regions where candidate balls have been found and with a more relaxed threshold, allowing to recompose the original shape of the object without considering obviously wrong candidates. 

Configuring the TPT thresholds is not an easy task, as it may widely varies depending on the specific conditions of the input video. Hence, it is implemented an automatic tuning of the TPT threshold. This can be done using a known reference location for the ball, selected in the setup phase described before.
 
\begin{itemize}
	\item 

\end{itemize}

\subsection{2D Trajectory Estimation}
\subsection{Camera Synchronization}
\subsection{3D trajectory Estimation}

\section{Algorithm}
\section{Experimental Results}
\section{Conclusions}

\bibliographystyle{ieeetr}% Select the citation style e.g. ieeetr
\bibliography{references}% write the directory to the .bib fil

This section records all revisions to the Document.
\newline \newline
\begin{tabular}{ | c | c | c | c | }
\hline
	Version & Date & Authors & Summary \\ \hline
	1.1 & 15/01/16 & Domenico Favaro, Caio Zuliani, Matheus Fim & Initial Release  \\ \hline
	1.2 & 17/01/16 & Domenico Favaro, Caio Zuliani, Matheus Fim & Second Release  \\ \hline
\end{tabular}

\subsection{Purpose and Scope}
The Integration Test Plan Document (ITPD) serves to present the integration sequence and testing for all Subsystems and Components that conform PowerEnjoy Car Sharing Service. This is a key part to guarantee the functioning and quality of the software. The Document will present the division of the System in Subsystems and Components that will endure individual testing as independent modules and then be subject to integration on the whole System.

\subsection{Definitions and Abbreviations}
\begin{itemize}
\item \textbf{RASD:} Reqirements And Specifications Document.
\item \textbf{DD:} Design Document.
\item \textbf{ITPD:} Integration Test Plan Document.
\item \textbf{SDK:} Software Development Kit
\item \textbf{App:} Application, refering to Web or Mobile App.
\item \textbf{Subsystem:} Part of the system the generally encapsulates one or more features.
\item \textbf{Component:} Self sustained part of the System that provides with functionalities and is part of one or more subsystems.
\item \textbf{Bottom-up:} Referring to Bottom-up testing. Each component at lower hierarchy is tested individually and then the components that rely upon these components are tested.
\item \textbf{Top-down:} Top-down integration testing is an integration testing technique used in order to mock or simulate the behaviour of the lower-level modules that are not yet integrated.
\item \textbf{Mock:} Simulation that mimic the behavior of certain objects and fucntions in controlled ways, done to test the behavior of some other object.
\end{itemize}
For other concepts concerning the Service definition look in the \textbf{Glossary} section of the RASD and DD.

\subsection{Reference Documents}
\begin{itemize}
\item Specification Document: Assignments AA 2016-2017.pdf
\item PowerEnjoy Requirements And Specifications Document (RASD)
\item PowerEnjoy Design Document (DD)
\item Example Document - Integration testing example document.pdf
\item Testing Tools Documentation:
\begin{itemize}
\item[-] JUnit User Guide - \url{http://junit.org/junit5/docs/current/user-guide/}
\item[-] Arquilian Guides - \url{http://arquillian.org/guides/}
\item[-] JMeter User Manual - \url{http://jmeter.apache.org/usermanual/}
\end{itemize}
\end{itemize}


\newpage
\section{Integration Strategy}
\subsection{Entry Criteria}
We define the criteria that must be met before integration testing of the system components. We consider Integration a part of the production development. In order for production to start all documentation must first be written and up to date, including RASD and DD, to have a clear and full scope of the system components functionalities and importance. Once in production, the integration of a singe component can be done when the following criteria is met:
\begin{itemize}
\item The Component feature must be 100\% complete, that is all classes and functions must have been implemented.
\item No tickets must be opened for the Component, no bugs or cosidered missing features must be present.
\item Individual component testing must have been performed, using JUnit to test its classes and functions.
\item All the interfaces the Component has to communicate to have to be present or at least mocked to be able to test its coupling.
\end{itemize}
  


\end{document}